from agent.TradingAgent import TradingAgent
from util.util import log_print

from math import sqrt
import numpy as np
import pandas as pd


class TraderAgent(TradingAgent):

    def __init__(self, id, name, type, symbol='IBM', starting_cash=100000,
                 log_orders=False, random_state=None):

        # Base class init.
        super().__init__(id, name, type, starting_cash=starting_cash, log_orders=log_orders, random_state=random_state)

        # Store important parameters particular to the ZI agent.
        self.symbol = symbol  # symbol to trade

        # The agent uses this to track whether it has begun its strategy or is still
        # handling pre-market tasks.
        self.trading = False

        # The agent begins in its "complete" state, not waiting for
        # any special event or condition.
        self.state = 'AWAITING_WAKEUP'

        # order to place
        self.order_to_place = []

        # GAN INFO
        self.received_orders = 0
        self.placed_orders = 0

        # The agent must track its previous wake time, so it knows how many time
        # units have passed.
        self.prev_wake_time = None

    def add_orders(self, new_orders):
        """ new order to handle generated by the GAN """
        self.received_orders += len(new_orders)
        self.order_to_place += new_orders
        self.order_to_place = sorted(self.order_to_place, key=lambda x: x[3])  # sort by time
        self.set_wakeup()

    def set_wakeup(self):
        """ set the new wakeup """
        if len(self.order_to_place) > 0:
            next_wake_up = self.order_to_place[0][3]
            self.setWakeup(next_wake_up)

    def kernelStarting(self, startTime):
        # self.kernel is set in Agent.kernelInitializing()
        # self.exchangeID is set in TradingAgent.kernelStarting()

        super().kernelStarting(startTime)

        self.oracle = self.kernel.oracle

    def kernelStopping(self):
        # Always call parent method to be safe.
        super().kernelStopping()

        # Print end of day valuation.
        H = int(round(self.getHoldings(self.symbol), -2) / 100)
        # May request real fundamental value from oracle as part of final cleanup/stats.
        #-------------------------------------------------
        #if self.symbol != 'ETF':
        rT = self.oracle.observePrice(self.symbol, self.currentTime, sigma_n=0, random_state=self.random_state)
        #else:
        #    portfolio_rT, rT = self.oracle.observePortfolioPrice(self.symbol, self.portfolio, self.currentTime,
        #                                                         sigma_n=0,
        #                                                         random_state=self.random_state)
        #-------------------------------------------------

        log_print(
            "{} final report.  Holdings {}, end cash {}, start cash {}, orders_done {}, orders_received {}",
            self.name, H, self.holdings['CASH'], self.starting_cash, self.placed_orders, self.received_orders)

    def wakeup(self, currentTime):
        # Parent class handles discovery of exchange times and market_open wakeup call.
        super().wakeup(currentTime)

        self.state = 'INACTIVE'

        if not self.mkt_open or not self.mkt_close:
            # TradingAgent handles discovery of exchange times.
            return
        else:
            if not self.trading:
                self.trading = True

                # Time to start trading!
                log_print("{} is ready to start trading now.", self.name)

        # Steady state wakeup behavior starts here.

        # If we've been told the market has closed for the day, we will only request
        # final price information, then stop.
        if self.mkt_closed and (self.symbol in self.daily_close_price):
            # Market is closed and we already got the daily close price.
            return

        # Schedule a wakeup for the next time this agent should arrive at the market
        # (following the conclusion of its current activity cycle).
        # We do this early in case some of our expected message responses don't arrive.

        # If the market has closed and we haven't obtained the daily close price yet,
        # do that before we cease activity for the day.  Don't do any other behavior
        # after market close.
        if self.mkt_closed and (not self.symbol in self.daily_close_price):
            self.getCurrentSpread(self.symbol)
            self.state = 'AWAITING_SPREAD'
            return

        # Cancel suspend orders? : TODO: check
        if False:
            self.cancelOrders()

        self.placeOrder()

    def placeOrder(self):
        """ place a new order """

        if len(self.order_to_place) == 0:
            return    # NO ORDER TO PLACE

        self.placed_orders += 1

        volume, price, direction, time_diff = self.order_to_place[0]
        self.placeLimitOrder(self.symbol, volume, direction > 0.5, price)

        # delete executed order and set new wakeup
        self.order_to_place = self.order_to_place[1:]
        self.set_wakeup()

    def receiveMessage(self, currentTime, msg):
        # Parent class schedules market open wakeup call once market open/close times are known.
        super().receiveMessage(currentTime, msg)

        # We have been awakened by something other than our scheduled wakeup.
        # If our internal state indicates we were waiting for a particular event,
        # check if we can transition to a new state.

    # Cancel all open orders.
    # Return value: did we issue any cancellation requests?
    def cancelOrders(self):
        if not self.orders: return False

        for id, order in self.orders.items():
            self.cancelOrder(order)

        return True
