from agent.TradingAgent import TradingAgent
from util.util import log_print

from math import sqrt
import numpy as np
import pandas as pd
import random
       

class TraderAgent(TradingAgent):

    def __init__(self, id, name, type, symbol='IBM', starting_cash=100000,
                 log_orders=False, random_state=None):

        # Base class init.
        super().__init__(id, name, type, starting_cash=starting_cash, log_orders=log_orders, random_state=random_state)

        # Store important parameters particular to the ZI agent.
        self.symbol = symbol  # symbol to trade

        random.seed(self.random_state.randint(low=0, high=2 ** 32))
        # The agent uses this to track whether it has begun its strategy or is still
        # handling pre-market tasks.
        self.trading = False

        # The agent begins in its "complete" state, not waiting for
        # any special event or condition.
        self.state = 'AWAITING_WAKEUP'

        # order to place
        self.order_to_place = []

        # GAN INFO
        self.received_orders = 0
        self.placed_orders = 0
        self.direction = []
        # The amount of orders to use in each timestamp
        self.max_order_gan = 60
        self.order_to_use_by_gan = 50

        self.count = 0
        # The agent must track its previous wake time, so it knows how many time
        # units have passed.
        self.prev_wake_time = None

    def getWakeFrequency(self):
        return pd.Timedelta(self.random_state.randint(low=0, high=100), unit='ns')

    def add_orders(self, new_orders):
        """ new order to handle generated by the GAN """
        # log stats
        self.direction += [int(t[2]) for t in new_orders]
        self.received_orders += len(new_orders)


        # TODO:  CHECK how much orders we want to save and use, and if we want ot override the preivous ones
        self.count += 1
        if self.count % 5 == 0:
            self.cancelOrders()

        # add new orders
        if self.order_to_use_by_gan >= self.max_order_gan:
            self.order_to_place = list(new_orders)  # TODO: += or just = ?
        else:
            ne = list(new_orders)
            random.shuffle(ne)  # TODO: random or just the first N-orders
            self.order_to_place = list(ne[:self.order_to_use_by_gan]) # TODO: += or just = ?

        self.order_to_place = sorted(self.order_to_place, key=lambda x: x[3])  # sort by time
        self.set_wakeup()

    def set_wakeup(self):
        """ set the new wakeup """
        if len(self.order_to_place) > 0:
            next_wake_up = self.order_to_place[0][3]
            self.setWakeup(next_wake_up)

    def kernelStarting(self, startTime):
        # self.kernel is set in Agent.kernelInitializing()
        # self.exchangeID is set in TradingAgent.kernelStarting()

        super().kernelStarting(startTime)

        self.oracle = self.kernel.oracle

    def kernelStopping(self):
        # Always call parent method to be safe.
        #super().kernelStopping()
        self.cancelOrders()
        from collections import Counter
        print(Counter(self.direction))        
        print(np.nanmean(self.direction))

        log_print(
            "{} final report.  Holdings {}, end cash {}, start cash {}, orders_done {}, orders_received {}",
            self.name, self.placed_orders, self.received_orders)

    def wakeup(self, currentTime):
        # Parent class handles discovery of exchange times and market_open wakeup call.
        super().wakeup(currentTime)

        self.state = 'INACTIVE'

        if not self.mkt_open or not self.mkt_close:
            # TradingAgent handles discovery of exchange times.
            return
        else:
            if not self.trading:
                self.trading = True

                # Time to start trading!
                log_print("{} is ready to start trading now.", self.name)

        # Steady state wakeup behavior starts here.

        # If we've been told the market has closed for the day, we will only request
        # final price information, then stop.
        if self.mkt_closed and (self.symbol in self.daily_close_price):
            # Market is closed and we already got the daily close price.
            return

        # Schedule a wakeup for the next time this agent should arrive at the market
        # (following the conclusion of its current activity cycle).
        # We do this early in case some of our expected message responses don't arrive.

        # If the market has closed and we haven't obtained the daily close price yet,
        # do that before we cease activity for the day.  Don't do any other behavior
        # after market close.
        if self.mkt_closed and (not self.symbol in self.daily_close_price):
            self.getCurrentSpread(self.symbol)
            self.state = 'AWAITING_SPREAD'
            return

        # Cancel suspend orders? : TODO: check
        if False:
            self.cancelOrders()

        self.placeOrder()

    def placeOrder(self):
        """ place a new order """

        if len(self.order_to_place) == 0:
            return    # NO ORDER TO PLACE

        self.placed_orders += 1

        volume, price, direction, time_diff = self.order_to_place[0]
        self.placeLimitOrder(self.symbol, volume, direction > 0.5, int(price))

        # delete executed order and set new wakeup
        self.order_to_place = self.order_to_place[1:]
        self.set_wakeup()

    def receiveMessage(self, currentTime, msg):
        # Parent class schedules market open wakeup call once market open/close times are known.
        super().receiveMessage(currentTime, msg)

        # We have been awakened by something other than our scheduled wakeup.
        # If our internal state indicates we were waiting for a particular event,
        # check if we can transition to a new state.

    # Cancel all open orders.
    # Return value: did we issue any cancellation requests?
    def cancelOrders(self):
        if not self.orders: return False


        # TODO: remove other that are olders that 5 minute
        for id, order in self.orders.items():
            if self.currentTime - order.time_placed > pd.Timedelta("5Min"):
                self.cancelOrder(order)

        return True
